#!/usr/bin/env python3
from __future__ import annotations
"""
Enrich crate_reference.md with:
- Scheduler callback info from crate_scheduler_map.csv (replace or append a section)
- Return-to-Base Predicates summary if available

Data sources:
- exports/crate_scheduler_map.csv (required)
- exports/crate_labels.json (optional for pretty names)
- exports/crate_return_predicates.csv (optional; generated by a separate scanner)
"""
import csv
from collections import defaultdict, Counter
import re, json
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
EXPORTS = ROOT / 'exports'
MAP = EXPORTS / 'crate_scheduler_map.csv'
REF = EXPORTS / 'crate_reference.md'
LABELS = EXPORTS / 'crate_labels.json'
RETURN_PRED = EXPORTS / 'crate_return_predicates.csv'
SLOT38 = EXPORTS / 'crate_slot38_installs.csv'
LINKAGE = EXPORTS / 'crate_return_linkage.csv'

if not (MAP.exists() and REF.exists()):
    raise SystemExit('Missing inputs')

rows = []
with MAP.open('r', encoding='utf-8', newline='') as f:
    rd = csv.DictReader(f)
    rows = list(rd)

labels = {}
if LABELS.exists():
    try:
        labels = json.loads(LABELS.read_text(encoding='utf-8', errors='ignore'))
    except Exception:
        labels = {}

by_slot = defaultdict(list)
for r in rows:
    slot = r.get('slot','')
    by_slot[slot].append(r)

def summarize(slot: str):
    items = by_slot.get(slot, [])
    cbs = Counter((r['cb1'], r['cb2']) for r in items)
    callers = Counter(r['caller'] for r in items)
    lines = []
    lines.append(f"### Slot {slot if slot else '(unspecified)'}")
    if not items:
        lines.append('_No entries_')
        lines.append('')
        return lines
    lines.append('Top callback pairs:')
    for (cb1, cb2), cnt in cbs.most_common(5):
        l1 = labels.get(cb1, cb1) if cb1 else '?'
        l2 = labels.get(cb2, cb2) if cb2 else '?'
        lines.append(f'- {l1} , {l2}  (x{cnt})')
    lines.append('Top callers:')
    for name, cnt in callers.most_common(8):
        lines.append(f'- {labels.get(name, name)} (x{cnt})')
    lines.append('')
    return lines

ref = REF.read_text(encoding='utf-8', errors='ignore')
summary_block = []
summary_block.append('## Scheduler Callback Summary')
summary_block.append('')
for slot in ['0x38','0x3c','0x40','']:
    summary_block.extend(summarize(slot))
summary_text = '\n'.join(summary_block) + '\n'

def replace_section(src: str, header: str, payload: str) -> str:
    # Replace text from header line to the line before the next '## ' header, preserving rest
    pattern = re.compile(rf"(^## {re.escape(header)}[\s\S]*?)(?=^## |\Z)", re.MULTILINE)
    if f"## {header}" in src:
        return re.sub(pattern, payload + ('\n' if not payload.endswith('\n') else ''), src)
    # Append if not present
    return src.rstrip() + '\n\n' + payload + ('\n' if not payload.endswith('\n') else '')

# Replace/append Scheduler Callback Summary section without affecting following content
new_ref = replace_section(ref, 'Scheduler Callback Summary', summary_text.rstrip())

def load_return_preds():
    preds = []
    if not RETURN_PRED.exists():
        return preds
    with RETURN_PRED.open('r', encoding='utf-8', newline='') as f:
        rd = csv.DictReader(f)
        preds = list(rd)
    return preds

def render_return_preds(preds):
    lines = []
    lines.append('## Crate: Return-to-Base Predicates')
    lines.append('')
    if not preds:
        # Fallback: slot 0x38 installs with nearby predicates (heuristic)
        if SLOT38.exists():
            try:
                with SLOT38.open('r', encoding='utf-8', newline='') as f:
                    rd = csv.DictReader(f)
                    rows38 = list(rd)
            except Exception:
                rows38 = []
            if rows38:
                lines.append('_Heuristic fallback from slot 0x38 installs scan._')
                lines.append('')
                lines.append('| function | predicate |')
                lines.append('|---|---|')
                seen = set()
                count = 0
                for r in rows38:
                    fn = labels.get(r.get('function',''), r.get('function',''))
                    pred = (r.get('predicate','') or '').replace('|','\\|')
                    key = (fn, pred)
                    if key in seen:
                        continue
                    seen.add(key)
                    lines.append(f"| {fn} | {pred or '(none found)'} |")
                    count += 1
                    if count >= 20:
                        break
                extra = len(rows38) - count
                if extra > 0:
                    lines.append(f"| ... | +{extra} more |")
                lines.append('')
                return '\n'.join(lines) + '\n'
        lines.append('_No predicate scan present. Run the return scanner to populate this section._')
        lines.append('')
        return '\n'.join(lines) + '\n'
    # Build base-slot cb1/cb2 sets for role classification
    base_rows = [r for r in rows if (r.get('slot') == '0x38' and r.get('cb1') and r.get('cb2'))]
    cb1_base = {r['cb1'] for r in base_rows}
    cb2_base = {r['cb2'] for r in base_rows}
    # Reverse labels: label -> FUN_*
    rev_labels = {}
    for fun, lab in labels.items():
        if isinstance(lab, str) and fun.startswith('FUN_'):
            rev_labels[lab] = fun
    # Build FUN_* versions of base sets for comparison against writer if it's FUN_*
    cb1_base_fun = {rev_labels.get(n, n) for n in cb1_base}
    cb2_base_fun = {rev_labels.get(n, n) for n in cb2_base}
    # Collect by role
    role_primary: list[dict] = []  # cb2 param (primary)
    role_secondary: list[dict] = []  # cb1 param (secondary)
    role_unknown: list[dict] = []
    for r in preds:
        writer = r.get('writer','')
        # classify allowing either label or FUN_* names
        if writer in cb2_base or writer in cb2_base_fun:
            role_primary.append(r)
        elif writer in cb1_base or writer in cb1_base_fun:
            role_secondary.append(r)
        else:
            role_unknown.append(r)

    def render_role(title: str, arr: list[dict]):
        if not arr:
            return
        lines.append(f"### {title}")
        lines.append('')
        lines.append('| callback | branch | predicate | evidence |')
        lines.append('|---|---|---|---|')
        for r in arr:
            cb = r.get('cb2','')
            cbn = labels.get(cb, cb)
            pred_full = r.get('predicate','')
            # Extract branch prefix like [if-true] if present
            m = re.match(r"\[(?P<br>[^\]]+)\]\s*(?P<p>.*)", pred_full)
            br = m.group('br') if m else ''
            pred = m.group('p') if m else pred_full
            ev = r.get('evidence','')
            lines.append(f"| {cbn} | {br} | {pred} | {ev} |")
        lines.append('')

    render_role('Primary (cb2 param)', role_primary)
    render_role('Secondary (cb1 param)', role_secondary)
    render_role('Unclassified', role_unknown)
    lines.append('')
    return '\n'.join(lines) + '\n'

preds = load_return_preds()
pred_text = render_return_preds(preds)

# Replace/append Return Predicates section similarly
new_ref = replace_section(new_ref, 'Crate: Return-to-Base Predicates', pred_text.rstrip())

# Also summarize implicit return installs (any scheduling to base slot 0x38)
def render_implicit_installs():
    lines = []
    lines.append('## Crate: Implicit Return Installs')
    lines.append('')
    base_rows = [r for r in rows if (r.get('slot') == '0x38')]
    if not base_rows:
        lines.append('_No base-slot installs detected in scheduler map._')
        lines.append('')
        return '\n'.join(lines) + '\n'
    # Group by pair
    pairs = defaultdict(list)
    for r in base_rows:
        key = (r.get('cb1','') or '?', r.get('cb2','') or '?')
        pairs[key].append(r)
    # Render per pair
    for (cb1, cb2), arr in sorted(pairs.items(), key=lambda kv: -len(kv[1])):
        l1 = labels.get(cb1, cb1)
        l2 = labels.get(cb2, cb2)
        lines.append(f"### Pair: {l1} , {l2}  (x{len(arr)})")
        callers = Counter(labels.get(r.get('caller',''), r.get('caller','')) for r in arr)
        for name, cnt in callers.most_common(10):
            lines.append(f"- {name} (x{cnt})")
        lines.append('')
    return '\n'.join(lines) + '\n'

implicit_text = render_implicit_installs()
new_ref = replace_section(new_ref, 'Crate: Implicit Return Installs', implicit_text.rstrip())

# Summarize base return drivers by caller with attached predicates if available
def render_base_return_drivers():
    lines = []
    lines.append('## Crate: Base Return Drivers')
    lines.append('')
    base_rows = [r for r in rows if (r.get('slot') == '0x38')]
    if not base_rows:
        lines.append('_No base-slot enqueues present in scheduler map._')
        lines.append('')
        return '\n'.join(lines) + '\n'
    # Collect predicates from slot38 scan (map by function label)
    preds_by_fn = {}
    if SLOT38.exists():
        try:
            with SLOT38.open('r', encoding='utf-8', newline='') as f:
                rd = csv.DictReader(f)
                for r in rd:
                    fn = labels.get(r.get('function',''), r.get('function',''))
                    pred = (r.get('predicate','') or '').strip()
                    if fn:
                        preds_by_fn.setdefault(fn, set()).add(pred or '(none found)')
        except Exception:
            pass
    # Group by caller
    by_caller = defaultdict(list)
    for r in base_rows:
        by_caller[r.get('caller','')].append(r)
    for caller, arr in sorted(by_caller.items(), key=lambda kv: -len(kv[1])):
        cname = labels.get(caller, caller)
        lines.append(f"### {cname}  (x{len(arr)})")
        # Pairs
        pairs = Counter((labels.get(r.get('cb1','') or '?', r.get('cb1','') or '?'),
                         labels.get(r.get('cb2','') or '?', r.get('cb2','') or '?')) for r in arr)
        for (cb1n, cb2n), cnt in pairs.most_common(3):
            lines.append(f"- Pair: {cb1n} , {cb2n}  (x{cnt})")
        # Predicates (if any)
        preds = sorted(preds_by_fn.get(cname, []))
        if preds:
            lines.append('- Predicates: ' + '; '.join(preds))
        lines.append('')
    return '\n'.join(lines) + '\n'

drivers_text = render_base_return_drivers()
new_ref = replace_section(new_ref, 'Crate: Base Return Drivers', drivers_text.rstrip())

def render_return_linkages():
    lines = []
    lines.append('## Crate: Return Linkages (cb → base)')
    lines.append('')
    if not LINKAGE.exists():
        lines.append('_Linkage scan not available._')
        lines.append('')
        return '\n'.join(lines) + '\n'
    with LINKAGE.open('r', encoding='utf-8', newline='') as f:
        rd = csv.DictReader(f)
        rows = list(rd)
    if not rows:
        lines.append('_No cb → base linkages found._')
        lines.append('')
        return '\n'.join(lines) + '\n'
    for r in rows[:20]:
        lines.append(f"- {labels.get(r.get('cb',''), r.get('cb',''))} ← {labels.get(r.get('driver',''), r.get('driver',''))} (depth {r.get('depth','')})")
        preds = r.get('predicates','')
        if preds:
            lines.append(f"  - predicates: {preds}")
    if len(rows) > 20:
        lines.append(f"- ... +{len(rows)-20} more")
    lines.append('')
    return '\n'.join(lines) + '\n'

link_text = render_return_linkages()
new_ref = replace_section(new_ref, 'Crate: Return Linkages (cb → base)', link_text.rstrip())

# Append a compact coverage summary at the end to track progress
def render_coverage_summary(src: str) -> str:
    pcount = 0
    try:
        if RETURN_PRED.exists():
            with RETURN_PRED.open('r', encoding='utf-8', newline='') as f:
                rd = csv.DictReader(f)
                pcount = sum(1 for _ in rd)
    except Exception:
        pcount = 0
    lcount = 0
    try:
        if LINKAGE.exists():
            with LINKAGE.open('r', encoding='utf-8', newline='') as f:
                rd = csv.DictReader(f)
                lcount = sum(1 for _ in rd)
    except Exception:
        lcount = 0
    text = []
    text.append('## Crate: Automation Coverage Summary')
    text.append('')
    text.append(f'- explicit return predicates: {pcount}')
    text.append(f'- cb → base linkages: {lcount}')
    text.append('')
    return '\n'.join(text) + '\n'

cov_text = render_coverage_summary(new_ref)
new_ref = replace_section(new_ref, 'Crate: Automation Coverage Summary', cov_text.rstrip())

REF.write_text(new_ref, encoding='utf-8')
print(f'Updated {REF}')
