#@category TB-Re
# Imports EOL and plate comments from a CSV generated by our tooling.
# CSV format: binary,ea,comment
# Filters rows to the current program by matching the 'binary' column.

import csv
import os

# Tolerate running outside Ghidra for linting: provide minimal stubs
try:
    from ghidra.program.model.listing import CodeUnit  # type: ignore
except Exception:  # pragma: no cover - non-Ghidra stub
    class CodeUnit:  # type: ignore
        EOL_COMMENT = 1

try:
    currentProgram  # type: ignore  # noqa: F401
except Exception:  # pragma: no cover
    currentProgram = None  # type: ignore

# Provide getFunctionAt() shim that defers to Ghidra when available
def getFunctionAt(addr):  # type: ignore
    fn = globals().get('getFunctionContaining')
    if fn:
        try:
            return fn(addr)  # provided by Ghidra
        except Exception:
            return None
    return None

def getSourceFile():  # type: ignore
    try:
        return __name__ and None  # Ghidra injects this; stub returns None outside
    except Exception:
        return None

def popup(msg):  # type: ignore
    try:
        print(msg)
    except Exception:
        pass

# Configure: path to CSV (default resolves relative to repo root if running via Ghidra's script manager)
DEFAULT_REL_PATH = os.path.join("..", "exports", "ghidra_comments.csv")

def matches_binary(current_name, bin_name):
    if not bin_name:
        return True
    cn = (current_name or "").lower()
    bn = (bin_name or "").lower()
    return cn.endswith(bn) or (bn in cn)

def parse_addr(addr_str):
    s = addr_str.strip()
    if s.startswith("0x") or s.startswith("0X"):
        s = s[2:]
    try:
        return currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(int(s, 16))  # type: ignore
    except Exception:
        return None

def import_comments(csv_path):
    listing = currentProgram.getListing()  # type: ignore
    prog_name = currentProgram.getName()  # type: ignore
    count = 0
    with open(csv_path, 'r', encoding='utf-8') as fh:
        reader = csv.DictReader(fh)
        for row in reader:
            bin_name = row.get('binary')
            if not matches_binary(prog_name, bin_name):
                continue
            addr = parse_addr(row.get('ea') or '')
            if addr is None:
                continue
            cmt = row.get('comment') or ''
            if not cmt:
                continue
            cu = listing.getCodeUnitAt(addr)
            if cu is None:
                cu = listing.getInstructionAt(addr)
            if cu is not None:
                cu.setComment(CodeUnit.EOL_COMMENT, cmt)
                count += 1
            # plate comment at function entry if applicable
            func = getFunctionAt(addr)
            if func is not None and func.getEntryPoint() == addr:
                prev = func.getComment() or ""
                sep = "\n" if prev else ""
                func.setComment(prev + sep + cmt)
    print("Imported {} comments from {}".format(count, csv_path))


def run():
    # Outside Ghidra, do nothing (prevents linter/runtime errors)
    if currentProgram is None:
        print("[ImportCommentsFromCSV] Skipping: not running inside Ghidra (currentProgram is None)")
        return
    base = os.path.dirname(getSourceFile().getAbsolutePath()) if getSourceFile() else os.getcwd()
    csv_path = os.path.abspath(os.path.join(base, DEFAULT_REL_PATH))
    if not os.path.exists(csv_path):
        popup("CSV not found: {}".format(csv_path))
        return
    import_comments(csv_path)

run()
