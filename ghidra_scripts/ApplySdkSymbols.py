# ApplySdkSymbols.py
# -----------------------------------------------------------------------------
# Ghidra headless/GUI script that reads canonical PSYQ symbol labels from
# exports/symbols/sdk_symbol_labels.json and applies them to the active program.
# Run via:
#
#   analyzeHeadless <proj_dir> <proj_name> \
#       -scriptPath ghidra_scripts \
#       -postScript ApplySdkSymbols.py labels="exports/symbols/sdk_symbol_labels.json"
#
# Optional arguments:
#   overwrite=true                -- replace existing USER_DEFINED labels at matching addresses
#   include_categories=gfx,audio  -- only apply labels whose categories intersect the provided set
#   exclude_categories=kernel     -- skip labels whose categories intersect the provided set
#
# The JSON payload is generated by scripts/build_sdk_symbol_labels.py and
# contains high-confidence symbol sightings distilled from PSYQ MAP files.
# -----------------------------------------------------------------------------

from __future__ import print_function

import importlib
import json
import os


def _load_ghidra_bindings():
    try:
        script_mod = importlib.import_module("ghidra.app.script")
        sym_mod = importlib.import_module("ghidra.program.model.symbol")
    except ImportError as exc:
        raise ImportError(
            "ApplySdkSymbols must run inside a Ghidra scripting environment."
        ) from exc

    return {
        "GhidraScript": script_mod.GhidraScript,
        "SourceType": sym_mod.SourceType,
    }


_BINDINGS = _load_ghidra_bindings()
GhidraScript = _BINDINGS["GhidraScript"]
SourceType = _BINDINGS["SourceType"]


class ApplySdkSymbols(GhidraScript):
    def run(self):
        args = self._parse_args(self.getScriptArgs())
        labels_path = self._resolve_path(
            args.get("labels", "exports/symbols/sdk_symbol_labels.json")
        )
        overwrite = args.get("overwrite", "false").lower() == "true"
        include_categories = self._parse_category_arg(args.get("include_categories"))
        exclude_categories = self._parse_category_arg(args.get("exclude_categories"))

        if not os.path.isfile(labels_path):
            raise IOError("Labels JSON not found: {0}".format(labels_path))
        if self.currentProgram is None:
            raise RuntimeError("No active program; open a binary before running script.")

        with open(labels_path, "r") as handle:
            records = json.load(handle)

        symbol_table = self.currentProgram.getSymbolTable()
        applied = 0
        skipped = 0
        considered = 0

        for record in records:
            name = record.get("symbol")
            addr_hex = record.get("address_hex")
            if not name or not addr_hex:
                continue
            categories = set(c.lower() for c in record.get("categories", []) if c)
            if include_categories:
                if not categories or categories.isdisjoint(include_categories):
                    continue
            if exclude_categories and not categories.isdisjoint(exclude_categories):
                continue
            considered += 1
            address = self.toAddr(addr_hex)
            primary = symbol_table.getPrimarySymbol(address)

            if primary is not None and primary.getName() == name:
                skipped += 1
                continue

            if primary is not None and primary.getSource() == SourceType.USER_DEFINED:
                if not overwrite:
                    skipped += 1
                    continue
                symbol_table.removeSymbolSpecial(primary)

            try:
                symbol_table.createLabel(address, name, SourceType.USER_DEFINED)
                applied += 1
            except Exception as err:  # pylint: disable=broad-except
                self.println("Failed to apply {0} at {1}: {2}".format(name, addr_hex, err))

        self.println(
            "ApplySdkSymbols complete: {0} applied, {1} skipped (considered {2} records).".format(
                applied, skipped, considered
            )
        )

    # ------------------------------------------------------------------
    def _parse_args(self, args):
        parsed = {}
        for token in args:
            if "=" not in token:
                continue
            key, value = token.split("=", 1)
            parsed[key.strip().lower()] = value.strip()
        return parsed

    def _resolve_path(self, path_value):
        if os.path.isabs(path_value):
            return path_value
        return os.path.abspath(os.path.join(os.getcwd(), path_value))

    def _parse_category_arg(self, value):
        if not value:
            return set()
        return {item.strip().lower() for item in value.split(",") if item.strip()}


def run():
    script = ApplySdkSymbols()
    script.run()


if __name__ == "__main__":
    run()
